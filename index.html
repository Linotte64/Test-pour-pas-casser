<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traducteur Fran√ßais ‚áÑ Nilfgaardien</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px;
        }
        .container {
            max-width: 1000px; margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; padding: 30px;
        }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #667eea; font-size: 2.5em; margin-bottom: 10px; }
        
        .translator {
            background: #f8f9fa; border-radius: 15px; padding: 25px; margin-bottom: 30px;
        }
        .translation-row {
            display: grid; grid-template-columns: 1fr auto 1fr; gap: 20px; align-items: center;
        }
        .translation-area label { font-weight: bold; margin-bottom: 10px; display: block; }
        .translation-area textarea { 
            width: 100%; height: 120px; border: 2px solid #e9ecef; 
            border-radius: 10px; padding: 15px; font-size: 16px; resize: none; 
        }
        .swap-btn { 
            background: linear-gradient(135deg, #ff6b6b, #feca57); 
            border: none; border-radius: 50%; width: 50px; height: 50px; 
            cursor: pointer; color: white; font-size: 20px;
        }
        
        .analysis { 
            background: #e3f2fd; border-radius: 10px; padding: 15px; margin-top: 20px;
        }
        .word-analysis { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
        .word-tag { 
            background: white; border: 1px solid #ddd; border-radius: 8px; 
            padding: 8px 12px; font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó°Ô∏è Traducteur Fran√ßais ‚áÑ Nilfgaardien üó°Ô∏è</h1>
            <p>Syst√®me de traduction avec conjugaisons automatiques</p>
        </div>
        
        <div class="translator">
            <h2>üîÑ Traduction</h2>
            <div class="translation-row">
                <div class="translation-area">
                    <label id="input-label">Fran√ßais</label>
                    <textarea id="input-text" placeholder="Tapez votre texte ici..."></textarea>
                </div>
                
                <button class="swap-btn" onclick="swapLanguages()">‚áÑ</button>
                
                <div class="translation-area">
                    <label id="output-label">Nilfgaardien</label>
                    <textarea id="output-text" placeholder="La traduction appara√Ætra ici..." readonly></textarea>
                </div>
            </div>
        </div>
        
        <div class="analysis" id="analysis" style="display:none;">
            <h3>üìã Analyse de la traduction</h3>
            <div class="word-analysis" id="word-analysis"></div>
            <div id="grammar-notes" style="margin-top: 15px;"></div>
        </div>
    <script>
console.log("Script d√©marr√©");
        // DICTIONNAIRE ENRICHI
        const dict = {
            verbs: {
    'danser': { ng_conj: 'addan', ng_radical: 'add', ng_inf: 'addan', fr_participle: 'dans√©', group: 1 },
    '√™tre': { ng_conj: 'ess', ng_radical: 'ess', ng_inf: 'essen', fr_participle: '√©t√©', group: 'irregular' },
    'aller': { ng_conj: 'var', ng_radical: 'var', ng_inf: 'varen', fr_participle: 'all√©', group: 'irregular' },
    'avoir': { ng_conj: 'caerme', ng_radical: 'caer', ng_inf: 'caermen', fr_participle: 'eu', group: 'irregular' },
    'finir': { ng_conj: 'finar', ng_radical: 'fin', ng_inf: 'finar', fr_participle: 'fini', group: 2 },
    'choisir': { ng_conj: 'dewisan', ng_radical: 'dewis', ng_inf: 'dewisan', fr_participle: 'choisi', group: 2 },
    'manger': { ng_conj: 'kroesan', ng_radical: 'kroes', ng_inf: 'kroesan', fr_participle: 'mang√©', group: 1 },
    'parler': { ng_conj: 'gwedan', ng_radical: 'gwed', ng_inf: 'gwedan', fr_participle: 'parl√©', group: 1 },
    'faire': { ng_conj: 'gwneuden', ng_radical: 'gwneud', ng_inf: 'gwneuden', fr_participle: 'fait', group: 'irregular' },
    'vaen': { ng_conj: 'vaen', ng_radical: 'vaen', ng_inf: 'vaenen', fr_participle: 'vaen', group: 'irregular' }
},
            nouns: {
                'b√™te': { ng: 'gorval', gender_fr: 'f', gender_ng: 'm' },
                'chat': { ng: 'mithel', gender_fr: 'm', gender_ng: 'f' },
                'chien': { ng: 'ci', gender_fr: 'm', gender_ng: 'm' },
                'eau': { ng: 'v√πtter', gender_fr: 'f', gender_ng: 'f' },
                'homme': { ng: 'dyn', gender_fr: 'm', gender_ng: 'm' },
                'femme': { ng: 'dynes', gender_fr: 'f', gender_ng: 'f' },
                'cheval': { ng: 'ceffyl', gender_fr: 'm', gender_ng: 'm' },
                'maison': { ng: 't≈∑', gender_fr: 'f', gender_ng: 'm' },
                'tertre': { ng: 'carn', gender_fr: 'm', gender_ng: 'm' },
                'ennemi': { ng: 'morvudd', gender_fr: 'm', gender_ng: 'm' }
            },
            adjectives: {
    'blanc': 'wen',
    'grand': 'mawr',
    'petit': 'bach',
    'noir': 'du',
    'rouge': 'coch',
    'vert': 'gwyrdd',
},
            expressions: {
                'flamme blanche': { ng: 'deithwen', gender_fr: 'f', gender_ng: 'm' },
                'au revoir': { ng: 'va faill', gender_fr: 'm', gender_ng: 'm' }
            },
            others: {
    'le': { ng: '', type: 'article' },
    'la': { ng: '', type: 'article' },
    'les': { ng: '', type: 'article' },
    'qui': { ng: '', type: 'pronom relatif' },
    'et': { ng: 'a', type: 'conjonction' },
    'sur': { ng: 'yn', type: 'pr√©position' }
},
            irregularPlurals: {
                '≈ìil': 'yeux',
                'oeil': 'yeux',
                'cheval': 'chevaux'
            },
            pronouns: {
    'je': { ng: '√©' },
    'tu': { ng: 'ti' },
    'il': { ng: 'ver' },
    'elle': { ng: 'vares' },
    'nous': { ng: '√©n' },
    'vous': { ng: 'tin' },
    'ils': { ng: 'vern' },
    'elles': { ng: 'veren' }
},
        };
        
        // CONJUGAISONS FRAN√áAISES COMPL√àTES
        const frenchConjugations = {
            group1: {
                pr√©sent: { je: 'e', tu: 'es', il: 'e', elle: 'e', nous: 'ons', vous: 'ez', ils: 'ent', elles: 'ent' },
                imparfait: { je: 'ais', tu: 'ais', il: 'ait', elle: 'ait', nous: 'ions', vous: 'iez', ils: 'aient', elles: 'aient' },
                futur: { je: 'erai', tu: 'eras', il: 'era', elle: 'era', nous: 'erons', vous: 'erez', ils: 'eront', elles: 'eront' }
            },
            group2: {
                pr√©sent: { je: 'is', tu: 'is', il: 'it', elle: 'it', nous: 'issons', vous: 'issez', ils: 'issent', elles: 'issent' },
                imparfait: { je: 'issais', tu: 'issais', il: 'issait', elle: 'issait', nous: 'issions', vous: 'issiez', ils: 'issaient', elles: 'issaient' },
                futur: { je: 'irai', tu: 'iras', il: 'ira', elle: 'ira', nous: 'irons', vous: 'irez', ils: 'iront', elles: 'iront' }
            },
            irregular: {
                '√™tre': {
                    pr√©sent: { je: 'suis', tu: 'es', il: 'est', elle: 'est', nous: 'sommes', vous: '√™tes', ils: 'sont', elles: 'sont' },
                    imparfait: { je: '√©tais', tu: '√©tais', il: '√©tait', elle: '√©tait', nous: '√©tions', vous: '√©tiez', ils: '√©taient', elles: '√©taient' },
                    futur: { je: 'serai', tu: 'seras', il: 'sera', elle: 'sera', nous: 'serons', vous: 'serez', ils: 'seront', elles: 'seront' }
                },
                'aller': {
                    pr√©sent: { je: 'vais', tu: 'vas', il: 'va', elle: 'va', nous: 'allons', vous: 'allez', ils: 'vont', elles: 'vont' },
                    imparfait: { je: 'allais', tu: 'allais', il: 'allait', elle: 'allait', nous: 'allions', vous: 'alliez', ils: 'allaient', elles: 'allaient' },
                    futur: { je: 'irai', tu: 'iras', il: 'ira', elle: 'ira', nous: 'irons', vous: 'irez', ils: 'iront', elles: 'iront' }
                },
                'avoir': {
                    pr√©sent: { je: 'ai', tu: 'as', il: 'a', elle: 'a', nous: 'avons', vous: 'avez', ils: 'ont', elles: 'ont' },
                    imparfait: { je: 'avais', tu: 'avais', il: 'avait', elle: 'avait', nous: 'avions', vous: 'aviez', ils: 'avaient', elles: 'avaient' },
                    futur: { je: 'aurai', tu: 'auras', il: 'aura', elle: 'aura', nous: 'aurons', vous: 'aurez', ils: 'auront', elles: 'auront' }
                },
                'faire': {
                    pr√©sent: { je: 'fais', tu: 'fais', il: 'fait', elle: 'fait', nous: 'faisons', vous: 'faites', ils: 'font', elles: 'font' },
                    imparfait: { je: 'faisais', tu: 'faisais', il: 'faisait', elle: 'faisait', nous: 'faisions', vous: 'faisiez', ils: 'faisaient', elles: 'faisaient' },
                    futur: { je: 'ferai', tu: 'feras', il: 'fera', elle: 'fera', nous: 'ferons', vous: 'ferez', ils: 'feront', elles: 'feront' }
                }
            }
        };
        
        // CONJUGAISONS NILFGAARDIENNES
        const ngConjugations = {
            pr√©sent: { je: 'en', tu: 'es', il: '', elle: '', nous: 'avam', vous: 'avel', ils: 'arin', elles: 'arin' },
            imparfait: { je: 'ien', tu: 'ias', il: 'ier', elle: 'ier', nous: 'iavem', vous: 'iavel', ils: 'iarn', elles: 'iarn' },
            futur: { je: 'rash', tu: 'resh', il: 'rin', elle: 'rin', nous: 'ravam', vous: 'ravel', ils: 'ranem', elles: 'ranim' }
        };
        
        let direction = 'fr-to-ng';
        // FONCTIONS DE PLURIEL
        function makeFrenchPlural(word) {
            if (dict.irregularPlurals[word.toLowerCase()]) {
                return dict.irregularPlurals[word.toLowerCase()];
            }
            
            if (word.endsWith('s') || word.endsWith('x') || word.endsWith('z')) return word;
            if (word.endsWith('eau')) return word + 'x';
            if (word.endsWith('al')) return word.slice(0, -2) + 'aux';
            if (word.endsWith('eu')) return word + 'x';
            
            return word + 's';
        }
        
        function makeNgPlural(word) {
            if (word.endsWith('n')) return word;
            if (word.endsWith('d')) return word + 'd';
            return word + 'n';
        }
        
        function detectFrenchPlural(word) {
            for (const [singular, plural] of Object.entries(dict.irregularPlurals)) {
                if (plural === word.toLowerCase()) {
                    return { singular: singular, isPlural: true };
                }
            }
            
            if (word.endsWith('s') || word.endsWith('x')) {
                let potential = word.slice(0, -1);
                if (dict.nouns[potential]) {
                    return { singular: potential, isPlural: true };
                }
                
                if (word.endsWith('aux')) {
                    potential = word.slice(0, -3) + 'al';
                    if (dict.nouns[potential]) {
                        return { singular: potential, isPlural: true };
                    }
                }
            }
            
            return { singular: word, isPlural: false };
        }
        
        function detectNgPlural(word) {
            if (word.endsWith('dd')) {
                const potential = word.slice(0, -1);
                for (const [frNoun, nounData] of Object.entries(dict.nouns)) {
                    if (nounData.ng === potential) {
                        return { singular: potential, isPlural: true, frSingular: frNoun };
                    }
                }
            }
            
            if (word.endsWith('n')) {
                const potential = word.slice(0, -1);
                for (const [frNoun, nounData] of Object.entries(dict.nouns)) {
                    if (nounData.ng === potential) {
                        return { singular: potential, isPlural: true, frSingular: frNoun };
                    }
                }
            }
            
            return { singular: word, isPlural: false };
        }
        
        // CONJUGAISONS
        function conjugateFrench(infinitive, person, tense = 'pr√©sent') {
            const verb = dict.verbs[infinitive];
            if (!verb) return infinitive;
            
            if (verb.group === 'irregular') {
                return frenchConjugations.irregular[infinitive]?.[tense]?.[person] || infinitive;
            }
            
            const radical = infinitive.slice(0, -2);
            const groupKey = verb.group === 1 ? 'group1' : 'group2';
            const ending = frenchConjugations[groupKey][tense][person];
            
            return radical + ending;
        }
        
      function conjugateNG(verbData, person, tense = 'pr√©sent', context = 'simple') {
    console.log(`conjugateNG appel√© avec: person=${person}, tense=${tense}, context=${context}`);
    
    if (tense === 'pr√©sent') {
        // 3√®me personne singulier
        if (person === 'il' || person === 'elle') {
            if (context === 'relative') {
                console.log(`Retour infinitif singulier: ${verbData.ng_inf}`);
                return verbData.ng_inf; // Infinitif pour les relatives singulier (addan)
            } else {
                console.log(`Retour radical singulier: ${verbData.ng_radical}`);
                return verbData.ng_radical; // Radical pour les phrases simples (add)
            }
        }
        // 3√®me personne pluriel
        else if (person === 'ils' || person === 'elles') {
            if (context === 'relative_plural' || context === 'relative') {
                console.log(`Retour radical + arin: ${verbData.ng_radical}arin`);
                return verbData.ng_radical + 'arin'; // Radical + arin pour les relatives pluriel (addarin)
            } else {
                console.log(`Retour radical + in: ${verbData.ng_radical}in`);
                return verbData.ng_radical + 'in'; // Radical + in pour les phrases simples (addin)
            }
        }
    }
    
    // Conjugaison normale pour les autres cas
    const ending = ngConjugations[tense]?.[person] || '';
    console.log(`Retour conjugu√©: ${verbData.ng_radical + ending}`);
    return verbData.ng_radical + ending;
}
            
function detectRelativeContext(words, verbIndex) {
    console.log(`D√©tection relative pour verbe √† l'index ${verbIndex}`, words);
    
    // Chercher "qui" ou "[qui]" juste avant le verbe
    if (verbIndex > 0) {
        const previousWord = words[verbIndex - 1];
        if (previousWord === 'qui' || previousWord.includes('ignor√© pour relative')) {
            console.log("Trouv√© 'qui' avant le verbe");
            
            // V√©rifier qu'il y a un nom/groupe nominal avant "qui"
            for (let i = verbIndex - 2; i >= 0; i--) {
                const word = words[i].toLowerCase();
                console.log(`Analyse du mot "${word}" √† l'index ${i}`);
                
                // NOUVEAU : D√©tecter les expressions remplac√©es
                if (word.startsWith('|expr:') && word.endsWith('|')) {
                    const exprNg = word.slice(6, -1); // Enlever |expr: et |
                    console.log(`Expression trouv√©e: ${exprNg}`);
                    
                    // Chercher l'expression dans le dictionnaire
                    for (const [frExpr, exprData] of Object.entries(dict.expressions)) {
                        if (exprData.ng === exprNg) {
                            console.log(`Expression identifi√©e: ${frExpr}`);
                            // Utiliser le genre de l'expression (toujours singulier pour l'instant)
                            return 'relative';
                        }
                    }
                }
                
                // D√©tecter pluriel avec articles pluriels
                if (['les', 'des'].includes(word)) {
                    console.log(`Article pluriel trouv√©: ${word}`);
                    return 'relative_plural';
                }
                
                // V√©rifier si c'est un pluriel fran√ßais
                const pluralCheck = detectFrenchPlural(word);
                if (pluralCheck.isPlural && dict.nouns[pluralCheck.singular]) {
                    console.log(`Nom pluriel trouv√©: ${word}`);
                    return 'relative_plural';
                }
                
                // Si on trouve un nom simple
                if (dict.nouns[word]) {
                    console.log(`Nom trouv√©: ${word}`);
                    return 'relative';
                }
                
                // V√©rifier les expressions de 2 mots
                if (i > 0) {
                    const expression = `${words[i-1]} ${word}`;
                    console.log(`Test expression: "${expression}"`);
                    if (dict.expressions[expression]) {
                        console.log(`Expression trouv√©e: ${expression}`);
                        return 'relative';
                    }
                }
                
                // Test si c'est un adjectif
                const adjResult = getSingularAdjective(word);
                console.log(`Test adjectif "${word}":`, adjResult);
                
                // Ignorer les articles/adjectifs singuliers, continuer la recherche
                if (['le', 'la', 'un', 'une'].includes(word) ||
                    dict.adjectives[word] ||
                    adjResult.found) {
                    console.log(`Mot ignor√©: ${word}`);
                    continue;
                }
                
                console.log(`Arr√™t sur: ${word}`);
                break;
            }
        }
    }
    return 'simple';
}
        
          function detectSubject(words) {
    // Chercher d'abord les pronoms nilfgaardiens
    for (const [frPronoun, pronounData] of Object.entries(dict.pronouns)) {
        if (words.includes(pronounData.ng)) {
            return frPronoun;
        }
    }
    
    // Chercher les pronoms fran√ßais
    const pronouns = ['je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles'];
    for (const word of words) {
        if (pronouns.includes(word.toLowerCase())) {
            return word.toLowerCase();
        }
    }
    
    // D√©tecter les noms au pluriel (avec articles pluriels)
    for (let i = 0; i < words.length - 1; i++) {
        const currentWord = words[i].toLowerCase();
        const nextWord = words[i + 1].toLowerCase();
        
        // V√©rifier si on a un article pluriel suivi d'un nom
        if (['les', 'des'].includes(currentWord)) {
            // V√©rifier si le mot suivant est un nom au pluriel
            const pluralCheck = detectFrenchPlural(nextWord);
            if (pluralCheck.isPlural && dict.nouns[pluralCheck.singular]) {
                return 'ils'; // Pluriel par d√©faut masculin
            }
            // Ou si c'est directement un nom connu au singulier mais utilis√© au pluriel
            if (dict.nouns[nextWord]) {
                return 'ils'; // "les chat" -> "ils" (m√™me si incorrect grammaticalement)
            }
        }
    }
    
    // Chercher un nom pour d√©terminer le genre (singulier)
    for (const word of words) {
        const noun = dict.nouns[word.toLowerCase()];
        if (noun) {
            return noun.gender_fr === 'm' ? 'il' : 'elle';
        }
        
        // Chercher aussi dans les noms nilfgaardiens
        for (const [frNoun, nounData] of Object.entries(dict.nouns)) {
            if (nounData.ng.toLowerCase() === word.toLowerCase()) {
                return nounData.gender_ng === 'm' ? 'il' : 'elle';
            }
        }
    }
    
    return 'il';
        }
        const ngAdjectiveRules = {
    // R√®gles de formation : pluriel d'abord, puis f√©minin
    makePlural: function(adj) {
        if (adj.endsWith('n')) return adj; // D√©j√† au pluriel
        if (adj.endsWith('d')) return adj + 'd';
        return adj + 'n';
    },
    
    makeFeminine: function(adj) {
        if (adj.endsWith('e')) return adj; // D√©j√† au f√©minin
        return adj + 'e';
    },
    
    // Application des r√®gles dans l'ordre
    applyAgreement: function(baseAdj, gender, isPlural) {
        let result = baseAdj;
        
        // 1. Pluriel d'abord
        if (isPlural) {
            result = this.makePlural(result);
        }
        
        // 2. F√©minin ensuite
        if (gender === 'f') {
            result = this.makeFeminine(result);
        }
        
        return result;
    }
};const frAdjectiveRules = {
    makeFeminine: function(adj) {
        if (adj.endsWith('e')) return adj;
        if (adj.endsWith('f')) return adj.slice(0, -1) + 've';
        if (adj.endsWith('x')) return adj.slice(0, -1) + 'se';
        if (adj.endsWith('er')) return adj.slice(0, -2) + '√®re';
        if (adj.endsWith('et')) return adj.slice(0, -2) + 'ette';
        if (adj.endsWith('on')) return adj + 'ne';
        if (adj.endsWith('en')) return adj + 'ne';
        if (adj.endsWith('el')) return adj + 'le';
        if (adj.endsWith('eil')) return adj + 'le';
        if (adj.endsWith('as')) return adj + 'se';
        if (adj.endsWith('os')) return adj + 'se';
        if (adj.endsWith('s')) return adj + 'se';
        return adj + 'e';
    },
    
    makePlural: function(adj) {
        if (adj.endsWith('s') || adj.endsWith('x')) return adj;
        if (adj.endsWith('eau')) return adj + 'x';
        if (adj.endsWith('al')) return adj.slice(0, -2) + 'aux';
        return adj + 's';
    },
    
    applyAgreement: function(baseAdj, gender, isPlural) {
        let result = baseAdj;
        
        // F√©minin d'abord en fran√ßais
        if (gender === 'f') {
            result = this.makeFeminine(result);
        }
        
        // Puis pluriel
        if (isPlural) {
            result = this.makePlural(result);
        }
        
        return result;
    }
};
        function getBaseAdjective(word) {
    // D'abord chercher directement dans le dictionnaire
    if (dict.adjectives[word]) {
        return { base: word, found: true };
    }
    
    // R√®gles automatiques pour retrouver le masculin √† partir du f√©minin
    
    // R√®gle simple : enlever le 'e' final
    if (word.endsWith('e') && word.length > 2) {
        const masculine = word.slice(0, -1);
        if (dict.adjectives[masculine]) {
            return { base: masculine, found: true };
        }
    }
    
    // R√®gles sp√©ciales fran√ßaises
    const transformRules = [
        { fem: 've', masc: 'f' },      // sportive ‚Üí sportif
        { fem: 'se', masc: 'x' },      // heureuse ‚Üí heureux  
        { fem: '√®re', masc: 'er' },    // premi√®re ‚Üí premier
        { fem: 'ette', masc: 'et' },   // coquette ‚Üí coquet
        { fem: 'nne', masc: 'n' },     // ancienne ‚Üí ancien
        { fem: 'lle', masc: 'l' },     // nouvelle ‚Üí nouvel
        { fem: 'sse', masc: 's' },     // grosse ‚Üí gros
        { fem: 'che', masc: 'c' },     // blanche ‚Üí blanc
        { fem: 'gue', masc: 'g' },     // longue ‚Üí long
    ];
    
    for (const rule of transformRules) {
        if (word.endsWith(rule.fem)) {
            const potential = word.slice(0, -rule.fem.length) + rule.masc;
            if (dict.adjectives[potential]) {
                return { base: potential, found: true };
            }
        }
    }
    
    // Cas sp√©ciaux irr√©guliers
    const irregularFeminines = {
        'blanche': 'blanc',
        'fra√Æche': 'frais',
        's√®che': 'sec',
        'publique': 'public',
        'grecque': 'grec',
        'turque': 'turc'
    };
    
    if (irregularFeminines[word] && dict.adjectives[irregularFeminines[word]]) {
        return { base: irregularFeminines[word], found: true };
    }
    
    return { base: word, found: false };
}

function getSingularAdjective(word) {
    // D'abord v√©rifier si c'est d√©j√† singulier
    const baseCheck = getBaseAdjective(word);
    if (baseCheck.found) {
        return baseCheck;
    }
    
    // R√®gles de pluriel fran√ßais
    if (word.endsWith('s') && !word.endsWith('ss')) {
        const singular = word.slice(0, -1);
        const singularCheck = getBaseAdjective(singular);
        if (singularCheck.found) {
            return singularCheck;
        }
    }
    
    if (word.endsWith('x')) {
        // Cas sp√©ciaux comme beaux ‚Üí beau
        const singular = word.slice(0, -1);
        const singularCheck = getBaseAdjective(singular);
        if (singularCheck.found) {
            return singularCheck;
        }
        
        // Cas eau ‚Üí eaux
        if (word.endsWith('eaux')) {
            const singular = word.slice(0, -1); // beaux ‚Üí beau
            const singularCheck = getBaseAdjective(singular);
            if (singularCheck.found) {
                return singularCheck;
            }
        }
    }
    
    return { base: word, found: false };
}
        function detectAdjectiveContext(words, adjIndex, direction) {
    let targetGender = 'm';
    let isPlural = false;
    let foundNoun = null;
    let bestScore = 0;
    
    console.log(`Analyse contexte pour adjectif "${words[adjIndex]}" √† l'index ${adjIndex}`);
    
    // Analyser chaque mot de la phrase pour trouver les noms potentiels
    for (let i = 0; i < words.length; i++) {
        if (i === adjIndex) continue; // Ignorer l'adjectif lui-m√™me
        
        const word = words[i].toLowerCase();
        const nounInfo = findNounInfo(word, direction);
        
        if (nounInfo && !nounInfo.pluralArticle) {
            // Calculer un score bas√© sur plusieurs crit√®res
            let score = 0;
            const distance = Math.abs(i - adjIndex);
            
            // 1. Proximit√© (plus c'est proche, mieux c'est)
            score += Math.max(0, 10 - distance);
            
            // 2. Position relative (apr√®s le nom = √©pith√®te, avant = attribut)
            if (i < adjIndex) {
                score += 3; // Bonus pour "nom + adjectif"
            }
            
            // 3. Pr√©sence d'articles/d√©terminants qui lient
            score += analyzeArticleContext(words, i, adjIndex, direction);
            
            // 4. D√©tection de structures grammaticales
            score += detectGrammarPattern(words, i, adjIndex);
            
            console.log(`Nom trouv√©: "${nounInfo.word}" √† distance ${distance}, score: ${score}`);
            
            if (score > bestScore) {
                bestScore = score;
                foundNoun = nounInfo;
                console.log(`Nouveau meilleur nom: "${nounInfo.word}" avec score ${score}`);
            }
        }
    }
    
    // D√©tection des articles pour le genre/nombre si pas de nom trouv√©
    if (!foundNoun) {
        const articleInfo = detectArticleGender(words, adjIndex);
        targetGender = articleInfo.gender;
        isPlural = articleInfo.isPlural;
        console.log(`Pas de nom trouv√©, utilisation articles: genre=${targetGender}, pluriel=${isPlural}`);
    } else {
        targetGender = direction === 'fr-to-ng' ? foundNoun.gender_ng : foundNoun.gender_fr;
        isPlural = foundNoun.isPlural;
        console.log(`Accord avec "${foundNoun.word}": genre=${targetGender}, pluriel=${isPlural}`);
    }
    
    return { gender: targetGender, isPlural: isPlural, noun: foundNoun?.word, score: bestScore };
}

function findNounInfo(word, direction) {
    // Ignorer les articles/mots fonctionnels
    if (['le', 'la', 'les', 'un', 'une', 'des', 'de', 'du', 'des', 'et', 'a'].includes(word)) {
        if (['les', 'des'].includes(word)) {
            return { isPlural: true, pluralArticle: true };
        }
        return null;
    }
    
    if (direction === 'fr-to-ng') {
        // Chercher nom fran√ßais
        if (dict.nouns[word]) {
            return { 
                word: word, 
                gender_fr: dict.nouns[word].gender_fr,
                gender_ng: dict.nouns[word].gender_ng,
                isPlural: false 
            };
        }
        
        // Chercher pluriel fran√ßais
        const pluralCheck = detectFrenchPlural(word);
        if (pluralCheck.isPlural && dict.nouns[pluralCheck.singular]) {
            return { 
                word: pluralCheck.singular,
                gender_fr: dict.nouns[pluralCheck.singular].gender_fr,
                gender_ng: dict.nouns[pluralCheck.singular].gender_ng,
                isPlural: true 
            };
        }
    } else {
        // Chercher nom nilfgaardien
        for (const [frNoun, nounData] of Object.entries(dict.nouns)) {
            if (nounData.ng === word) {
                return { 
                    word: frNoun,
                    gender_fr: nounData.gender_fr,
                    gender_ng: nounData.gender_ng,
                    isPlural: false 
                };
            }
        }
        
        // Chercher pluriel nilfgaardien
        const ngPluralCheck = detectNgPlural(word);
        if (ngPluralCheck.isPlural && ngPluralCheck.frSingular) {
            return { 
                word: ngPluralCheck.frSingular,
                gender_fr: dict.nouns[ngPluralCheck.frSingular].gender_fr,
                gender_ng: dict.nouns[ngPluralCheck.frSingular].gender_ng,
                isPlural: true 
            };
        }
    }
    
    return null;
}
        function analyzeArticleContext(words, nounIndex, adjIndex, direction) {
    let score = 0;
    const range = 3; // Chercher dans un rayon de 3 mots
    
    // Chercher des articles/d√©terminants qui lient nom et adjectif
    const start = Math.max(0, Math.min(nounIndex, adjIndex) - range);
    const end = Math.min(words.length, Math.max(nounIndex, adjIndex) + range);
    
    for (let i = start; i < end; i++) {
        const word = words[i].toLowerCase();
        
        // Articles d√©finis/ind√©finis
        if (['le', 'la', 'les', 'un', 'une', 'des'].includes(word)) {
            score += 2;
        }
        
        // D√©terminants possessifs
        if (['mon', 'ma', 'mes', 'ton', 'ta', 'tes', 'son', 'sa', 'ses', 'notre', 'nos', 'votre', 'vos', 'leur', 'leurs'].includes(word)) {
            score += 2;
        }
        
        // D√©terminants d√©monstratifs
        if (['ce', 'cet', 'cette', 'ces'].includes(word)) {
            score += 2;
        }
    }
    
    return score;
}

function detectGrammarPattern(words, nounIndex, adjIndex) {
    let score = 0;
    
    // Patterns communs en fran√ßais
    const distance = Math.abs(nounIndex - adjIndex);
    
    // Pattern: "nom + adjectif" (√©pith√®te)
    if (adjIndex === nounIndex + 1) {
        score += 5; // "chat noir"
    }
    
    // Pattern: "adjectif + nom" (√©pith√®te ant√©pos√©e)
    if (nounIndex === adjIndex + 1) {
        score += 3; // "grand homme"
    }
    
    // Pattern: "nom + √™tre/devenir + adjectif" (attribut)
    if (distance <= 3) {
        for (let i = Math.min(nounIndex, adjIndex); i < Math.max(nounIndex, adjIndex); i++) {
            const word = words[i].toLowerCase();
            if (['est', 'sont', '√©tait', '√©taient', 'sera', 'seront', 'devient', 'deviennent'].includes(word)) {
                score += 4; // "le chat est noir"
            }
        }
    }
    
    // Pattern: "nom + qui + verbe + adjectif" (proposition relative)
    if (distance <= 5) {
        let hasQui = false;
        let hasVerb = false;
        
        for (let i = Math.min(nounIndex, adjIndex); i < Math.max(nounIndex, adjIndex); i++) {
            const word = words[i].toLowerCase();
            if (word === 'qui') hasQui = true;
            if (['est', 'sont', 'devient', 'semble', 'para√Æt'].includes(word)) hasVerb = true;
        }
        
        if (hasQui && hasVerb) {
            score += 3; // "le chat qui est noir"
        }
    }
    
    return score;
}

function detectArticleGender(words, adjIndex) {
    let gender = 'm';
    let isPlural = false;
    
    // Chercher dans un rayon de 5 mots autour de l'adjectif
    for (let distance = 1; distance <= 5; distance++) {
        // Chercher avant
        if (adjIndex - distance >= 0) {
            const word = words[adjIndex - distance].toLowerCase();
            const articleInfo = getArticleInfo(word);
            if (articleInfo) {
                return articleInfo;
            }
        }
        
        // Chercher apr√®s
        if (adjIndex + distance < words.length) {
            const word = words[adjIndex + distance].toLowerCase();
            const articleInfo = getArticleInfo(word);
            if (articleInfo) {
                return articleInfo;
            }
        }
    }
    
    return { gender, isPlural };
}

function getArticleInfo(word) {
    const articles = {
        'la': { gender: 'f', isPlural: false },
        'une': { gender: 'f', isPlural: false },
        'le': { gender: 'm', isPlural: false },
        'un': { gender: 'm', isPlural: false },
        'les': { gender: 'm', isPlural: true }, // Par d√©faut masculin pluriel
        'des': { gender: 'm', isPlural: true },
        'ma': { gender: 'f', isPlural: false },
        'ta': { gender: 'f', isPlural: false },
        'sa': { gender: 'f', isPlural: false },
        'mon': { gender: 'm', isPlural: false },
        'ton': { gender: 'm', isPlural: false },
        'son': { gender: 'm', isPlural: false },
        'mes': { gender: 'm', isPlural: true },
        'tes': { gender: 'm', isPlural: true },
        'ses': { gender: 'm', isPlural: true },
        'cette': { gender: 'f', isPlural: false },
        'ce': { gender: 'm', isPlural: false },
        'cet': { gender: 'm', isPlural: false },
        'ces': { gender: 'm', isPlural: true }
    };
    
    return articles[word] || null;
            }
        function makeNgParticiple(verbData) {
    return verbData.ng_radical + 'at';
}

function findVerbFromParticiple(participle) {
    // Chercher directement dans le dictionnaire
    for (const [infinitive, verbData] of Object.entries(dict.verbs)) {
        if (verbData.fr_participle === participle) {
            return infinitive;
        }
    }
    return null;
}
        // TRADUCTIONS
        function preprocessFrenchText(text) {
    let processedText = text.toLowerCase();
    
    // R√®gle 1: j' + voyelle/h ‚Üí je + mot
    processedText = processedText.replace(/\bj'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'je $1');
    
    // R√®gle 2 am√©lior√©e: l' + voyelle/h ‚Üí le/la selon le genre du mot
    processedText = processedText.replace(/\bl'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø]\w*)/g, function(match, word) {
        // V√©rifier le genre dans le dictionnaire
        if (dict.nouns[word] && dict.nouns[word].gender_fr === 'f') {
            return 'la ' + word;
        }
        return 'le ' + word;  // Par d√©faut masculin
    });
    
    // R√®gle 3: d' + voyelle/h ‚Üí de + mot
    processedText = processedText.replace(/\bd'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'de $1');
    
    // R√®gle 4: qu' + voyelle/h ‚Üí que + mot
    processedText = processedText.replace(/\bqu'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'que $1');
    
    // R√®gle 5: n' + voyelle/h ‚Üí ne + mot (n√©gation)
    processedText = processedText.replace(/\bn'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'ne $1');
    
    // R√®gle 6: t' + voyelle/h ‚Üí te + mot
    processedText = processedText.replace(/\bt'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'te $1');
    
    // R√®gle 7: s' + voyelle/h ‚Üí se + mot
    processedText = processedText.replace(/\bs'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'se $1');
    
    // R√®gle 8: m' + voyelle/h ‚Üí me + mot
    processedText = processedText.replace(/\bm'([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, 'me $1');
    
    // Cas sp√©ciaux fr√©quents qu'on peut corriger manuellement
    const specialCases = {
        "c'est": "ce est",
        "c'√©tait": "ce √©tait",
        "c'√©taient": "ce √©taient",
        "aujourd'hui": "aujourd hui"  // Garde comme un seul mot
    };
    
    for (const [contraction, expansion] of Object.entries(specialCases)) {
        const regex = new RegExp('\\b' + contraction.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        processedText = processedText.replace(regex, expansion);
    }
    
    return processedText;
         }
        function translateFrToNg(text) {
    // Pr√©processing des contractions
    text = preprocessFrenchText(text);
    
    // Expressions compos√©es (traitement partiel)
    let textToProcess = text.toLowerCase();

            let expressionAnalysis = [];

            for (const [expr, data] of Object.entries(dict.expressions)) {
                const regex = new RegExp('\\b' + expr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'g');
                if (regex.test(textToProcess)) {
                    textToProcess = textToProcess.replace(regex, `|EXPR:${data.ng}|`);
                    expressionAnalysis.push({ original: expr, translation: data.ng, type: 'expression' });
                }
            }
            
            const words = textToProcess.split(' ');
            const subject = detectSubject(text.toLowerCase().split(' '));
            let result = [];
            let analysis = [...expressionAnalysis];
            
            for (let i = 0; i < words.length; i++) {
                let word = words[i];
                let found = false;
                
                // V√©rifier si c'est une expression remplac√©e
                if (word.startsWith('|EXPR:') && word.endsWith('|')) {
                    result.push(word.slice(6, -1));
                    found = true;
                }
                
                if (!found) {
                    // FUTUR PROCHE (aller + infinitif ‚Üí voor + infinitif)
if (['vais', 'vas', 'va', 'allons', 'allez', 'vont'].includes(word) && i + 1 < words.length) {
    const nextWord = words[i + 1];
    const verb = dict.verbs[nextWord];
    if (verb) {
        result.push(`voor ${verb.ng_radical}`);
        analysis.push({
            original: `${word} ${nextWord}`,
            translation: `voor ${verb.ng_radical}`,
            type: 'futur proche'
        });
        i++; // Passer au mot suivant
        continue;
    }
}

// FUTUR ANT√âRIEUR (aurai + participe ‚Üí vaen + participe)
if (['aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront'].includes(word) && i + 1 < words.length) {
    const nextWord = words[i + 1];
    const participleVerb = findVerbFromParticiple(nextWord);
    if (participleVerb) {
        const vaenForm = conjugateNG(dict.verbs['vaen'], subject, 'pr√©sent');
        const ngParticiple = makeNgParticiple(dict.verbs[participleVerb]);
        result.push(`${vaenForm} ${ngParticiple}`);
        analysis.push({
            original: `${word} ${nextWord}`,
            translation: `${vaenForm} ${ngParticiple}`,
            type: 'futur ant√©rieur'
        });
        i++; // Passer au mot suivant
        continue;
    }
}
                    
                    // GESTION "DE + POSSESSIF" ‚Üí "AEP"
                    if (word === 'de' && i + 1 < words.length) {
                        const nextWord = words[i + 1];
                        if (['mon', 'ton', 'son', 'sa', 'ses', 'notre', 'votre', 'leur', 'leurs'].includes(nextWord)) {
                            result.push('aep');
                            analysis.push({
                                original: `${word} ${nextWord}`,
                                translation: 'aep',
                                type: 'de + possessif ‚Üí aep'
                            });
                            i++; // Passer au mot suivant
                            continue;
                        }
                    }
                    
                    // Verbes (avec tous les temps)
                    // Verbes (avec tous les temps)
for (const [frVerb, verbData] of Object.entries(dict.verbs)) {
    for (const tense of ['pr√©sent', 'imparfait', 'futur']) {
        const conjugated = conjugateFrench(frVerb, subject, tense);
        if (conjugated === word) {
            // D√©tecter le contexte pour la 3√®me personne
            let context = 'simple';
            if (['il', 'elle', 'ils', 'elles'].includes(subject) && tense === 'pr√©sent') {
    context = detectRelativeContext(words, i);
}
            
            const ngForm = conjugateNG(verbData, subject, tense, context);
            result.push(ngForm);
            analysis.push({ 
                original: word, 
                translation: ngForm, 
                type: `verbe (${subject}, ${tense}, ${context})` 
            });
            found = true;
            break;
        }
        }
    if (found) break;
        }        
                    if (!found) {
                        // Noms (singulier et pluriel)
                        const noun = dict.nouns[word];
                        if (noun) {
                            result.push(noun.ng);
                            analysis.push({ original: word, translation: noun.ng, type: 'nom (singulier)' });
                            found = true;
                        } else {
                            const pluralCheck = detectFrenchPlural(word);
                            if (pluralCheck.isPlural && dict.nouns[pluralCheck.singular]) {
                                const singularNoun = dict.nouns[pluralCheck.singular];
                                const ngPlural = makeNgPlural(singularNoun.ng);
                                result.push(ngPlural);
                                analysis.push({ 
                                    original: word, 
                                    translation: ngPlural, 
                                    type: 'nom (pluriel)' 
                                });
                                found = true;
                            }
                        }
                    }
                    
                    if (!found) {
    // Adjectifs avec accord (gestion automatique des formes)
    const adjInfo = getSingularAdjective(word);
    if (adjInfo.found) {
        const ngAdj = dict.adjectives[adjInfo.base];
        const context = detectAdjectiveContext(words, i, 'fr-to-ng');
        const accordedAdj = ngAdjectiveRules.applyAgreement(ngAdj, context.gender, context.isPlural);
        result.push(accordedAdj);
        analysis.push({ 
            original: word, 
            translation: accordedAdj, 
            type: `adjectif (${adjInfo.base}) ‚Üí ${context.noun || '?'} (${context.gender}, ${context.isPlural ? 'pl' : 'sg'})` 
        });
        found = true;
    }
}
                    if (!found) {
    // Pronoms personnels
    const pronoun = dict.pronouns[word];
    if (pronoun) {
        result.push(pronoun.ng);
        analysis.push({ original: word, translation: pronoun.ng, type: 'pronom' });
        found = true;
    }
                    }
                    
                    if (!found) {
    // Traitement sp√©cial pour "qui"
    if (word === 'qui') {
        // D√©tection contextuelle : interrogatif vs relatif
        if (i === 0 || i === 1) {
            // D√©but de phrase = interrogatif, traduire normalement
            result.push('[qui-interrogatif]'); // √Ä remplacer par la vraie traduction
            analysis.push({ original: word, translation: '[qui-interrogatif]', type: 'pronom interrogatif' });
        } else {
            // Probable relatif - ignorer pour la d√©tection
            analysis.push({ original: word, translation: '[ignor√© pour relative]', type: 'pronom relatif' });
        }
        found = true;
    }
    
    // Autres mots
    if (!found) {
        const other = dict.others[word];
        if (other && (other.ng !== '' || other.show)) {
            if (other.ng !== '') {
                result.push(other.ng);
                analysis.push({ original: word, translation: other.ng, type: other.type });
            } else {
                analysis.push({ original: word, translation: '[ignor√©]', type: other.type });
            }
            found = true;
        }
    }
}
                    
                    if (!found) {
                        result.push(`[${word}]`);
                        analysis.push({ original: word, translation: '[inconnu]', type: 'inconnu' });
                    }
                }
            }
            
            return {
                translation: result.join(' '),
                analysis: analysis,
                grammar: [`Sujet: ${subject}`]
            };
        }
            function translateNgToFr(text) {
            // Expressions compos√©es (traitement partiel)
            let textToProcess = text.toLowerCase();
            let expressionAnalysis = [];

            for (const [frExpr, ngData] of Object.entries(dict.expressions)) {
                const regex = new RegExp('\\b' + ngData.ng.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'g');
                if (regex.test(textToProcess)) {
                    textToProcess = textToProcess.replace(regex, `|EXPR:${frExpr}|`);
                    expressionAnalysis.push({ original: ngData.ng, translation: frExpr, type: 'expression' });
                }
            }

            const words = textToProcess.split(' ');
            const subject = detectSubject(text.toLowerCase().split(' '));
            let result = [];
            let analysis = [...expressionAnalysis];

            for (let i = 0; i < words.length; i++) {
                let word = words[i];
                let found = false;
                
                // V√©rifier si c'est une expression remplac√©e
                if (word.startsWith('|EXPR:') && word.endsWith('|')) {
                    result.push(word.slice(6, -1));
                    found = true;
                }
                
                if (!found) {
                    // FUTUR PROCHE (voor + infinitif ‚Üí aller + infinitif)
                    if (word === 'voor' && i + 1 < words.length) {
                        const nextWord = words[i + 1];
                        // Chercher le verbe nilfgaardien correspondant
                        for (const [frVerb, verbData] of Object.entries(dict.verbs)) {
                            if (verbData.ng_radical === nextWord) {
                                const allerForm = conjugateFrench('aller', subject, 'pr√©sent');
                                result.push(`${allerForm} ${frVerb}`);
                                analysis.push({
                                    original: `${word} ${nextWord}`,
                                    translation: `${allerForm} ${frVerb}`,
                                    type: 'futur proche'
                                });
                                i++; // Passer au mot suivant
                                found = true;
                                break;
                            }
                        }
                        if (found) continue;
                    }
                    // FUTUR ANT√âRIEUR NG ‚Üí FR (vaen + participe ‚Üí aurai + participe)
if (word.startsWith('vaen') && i + 1 < words.length) {
    const nextWord = words[i + 1];
    // V√©rifier si le mot suivant est un participe nilfgaardien (finit par 'at')
    if (nextWord.endsWith('at')) {
        // Retrouver le verbe fran√ßais correspondant
        const radical = nextWord.slice(0, -2);
        for (const [frVerb, verbData] of Object.entries(dict.verbs)) {
            if (verbData.ng_radical === radical) {
                const auraiForm = conjugateFrench('avoir', subject, 'futur');
                result.push(`${auraiForm} ${verbData.fr_participle}`);
                analysis.push({
                    original: `${word} ${nextWord}`,
                    translation: `${auraiForm} ${verbData.fr_participle}`,
                    type: 'futur ant√©rieur'
                });
                i++; // Passer au mot suivant
                found = true;
                break;
            }
        }
        if (found) continue;
    }
}
                    
                    // GESTION "AEP" ‚Üí Analyser le contexte pour "DE + POSSESSIF"
                    if (word === 'aep') {
                        // Pour l'instant, traduction simple bas√©e sur le sujet d√©tect√©
                        let possessif = 'de ses'; // Par d√©faut
                        
                        if (subject === 'je') possessif = 'de mes';
                        else if (subject === 'tu') possessif = 'de tes';
                        else if (subject === 'il' || subject === 'elle') possessif = 'de ses';
                        else if (subject === 'nous') possessif = 'de nos';
                        else if (subject === 'vous') possessif = 'de vos';
                        else if (subject === 'ils' || subject === 'elles') possessif = 'de leurs';
                        
                        // Analyser le mot suivant pour le genre/nombre si possible
                        if (i + 1 < words.length) {
                            const nextWord = words[i + 1];
                            console.log(`Analyse du mot apr√®s aep: ${nextWord}`);
                            
                            // V√©rifier si c'est un nom connu
                            for (const [frNoun, nounData] of Object.entries(dict.nouns)) {
                                if (nounData.ng === nextWord) {
                                    console.log(`Nom trouv√©: ${frNoun}, genre: ${nounData.gender_fr}`);
                                    // Ajuster selon le genre et nombre
                                    if (subject === 'il' || subject === 'elle') {
                                        if (nounData.gender_fr === 'm') {
                                            possessif = 'de son';
                                        } else {
                                            possessif = 'de sa';
                                        }
                                    }
                                    break;
                                }
                            }
 
                            // V√©rifier si c'est un pluriel nilfgaardien
                            const pluralCheck = detectNgPlural(nextWord);
                            if (pluralCheck.isPlural) {
                                console.log(`Pluriel d√©tect√©: ${nextWord}`);
                                if (subject === 'il' || subject === 'elle') {
                                    possessif = 'de ses';
                                }
                            }
                        }
                        
                        result.push(possessif);
                        analysis.push({
                            original: word,
                            translation: possessif,
                            type: `aep ‚Üí ${possessif} (contexte: sujet ${subject})`
                        });
                        found = true;
                    }
                                               
           // Verbes √† l'infinitif (probablement des relatives)
for (const [frVerb, verbData] of Object.entries(dict.verbs)) {
    // Relatives plurielles (radical + arin)
    if (word === verbData.ng_radical + 'arin') {
        const frForm = conjugateFrench(frVerb, 'ils', 'pr√©sent');
        result.push(`qui ${frForm}`);
        analysis.push({ 
            original: word, 
            translation: `qui ${frForm}`, 
            type: `verbe relatif pluriel` 
        });
        found = true;
        break;
    }
    // Relatives singuli√®res (infinitif simple)
    else if (verbData.ng_inf === word) {
        const frForm = conjugateFrench(frVerb, subject, 'pr√©sent');
        result.push(`qui ${frForm}`);
        analysis.push({ 
            original: word, 
            translation: `qui ${frForm}`, 
            type: `verbe relatif singulier (${subject})` 
        });
        found = true;
        break;
    }
}
                    // Verbes conjugu√©s
                    for (const [frVerb, verbData] of Object.entries(dict.verbs)) {
                        for (const tense of ['pr√©sent', 'imparfait', 'futur']) {
                            for (const person of ['je', 'tu', 'il', 'elle', 'nous', 'vous', 'ils', 'elles']) {
                               const ngForm = conjugateNG(verbData, person, tense, 'simple');
                                if (ngForm === word) {
                                    const frForm = conjugateFrench(frVerb, person, tense);
                                    result.push(frForm);
                                    analysis.push({ 
                                        original: word, 
                                        translation: frForm, 
                                        type: `verbe (${subject}, ${tense})` 
                                    });
                                    found = true;
                                    break;
                                }
                            }
                            if (found) break;
                        }
                        if (found) break;
                    }
                    
                    if (!found) {
                        // Noms avec articles
                        for (const [frNoun, nounData] of Object.entries(dict.nouns)) {
                            if (nounData.ng === word) {
                                const article = nounData.gender_fr === 'm' ? 'le ' : 'la ';
                                result.push(article + frNoun);
                                analysis.push({ original: word, translation: article + frNoun, type: 'nom' });
                                found = true;
                                break;
                            }
                        }
                        
                        if (!found) {
                            // Pluriels NG
                            const pluralCheck = detectNgPlural(word);
                            if (pluralCheck.isPlural && pluralCheck.frSingular) {
                                const frPlural = makeFrenchPlural(pluralCheck.frSingular);
                                result.push('les ' + frPlural);
                                analysis.push({ 
                                    original: word, 
                                    translation: 'les ' + frPlural, 
                                    type: 'nom (pluriel)' 
                                });
                                found = true;
                            }
                        }
                    }
                    
                    if (!found) {
// Adjectifs avec accord
for (const [frAdj, ngAdj] of Object.entries(dict.adjectives)) {
    if (ngAdj === word || ngAdjectiveRules.applyAgreement(ngAdj, 'f', false) === word || 
        ngAdjectiveRules.applyAgreement(ngAdj, 'm', true) === word || 
        ngAdjectiveRules.applyAgreement(ngAdj, 'f', true) === word) {
        
        const context = detectAdjectiveContext(words, i, 'ng-to-fr');
        const accordedAdj = frAdjectiveRules.applyAgreement(frAdj, context.gender, context.isPlural);
        result.push(accordedAdj);
        analysis.push({ 
            original: word, 
            translation: accordedAdj, 
            type: `adjectif ‚Üí ${context.noun || '?'} (${context.gender}, ${context.isPlural ? 'pl' : 'sg'})` 
        });
        found = true;
        break;
                            }
                        }
                    }
                    if (!found) {
    // Pronoms personnels
    for (const [frPronoun, pronounData] of Object.entries(dict.pronouns)) {
        if (pronounData.ng === word) {
            result.push(frPronoun);
            analysis.push({ original: word, translation: frPronoun, type: 'pronom' });
            found = true;
            break;
        }
    }
        }
                    if (!found) {
                        // Autres (incluant pronoms)
                        const other = dict.others[word];
                        if (other && (other.ng !== '' || other.show)) {
                            if (other.ng !== '') {
                                result.push(other.ng);
                                analysis.push({ original: word, translation: other.ng, type: other.type });
                            } else {
                                analysis.push({ original: word, translation: '[ignor√©]', type: other.type });
                            }
                            found = true;
                        }
                    }
                    
                    if (!found) {
                        result.push(`[${word}]`);
                        analysis.push({ original: word, translation: '[inconnu]', type: 'inconnu' });
                    }
                }
            }
            
           // Nettoyer les balises d'expressions mal trait√©es
let finalTranslation = result.join(' ');
finalTranslation = finalTranslation.replace(/\\[\\|EXPR:([^\\]]+)\\]/g, '$1');
finalTranslation = finalTranslation.replace(/\\[([^\\]]+)\\|\\]/g, '$1');
finalTranslation = finalTranslation.replace(/\\|EXPR:([^|]+)\\|/g, '$1');
                
return {
    translation: postprocessFrenchText(finalTranslation),
    analysis: analysis,
    grammar: [`Sujet: ${subject}`]
};
        }
        function postprocessFrenchText(text) {
    // Reconstituer les apostrophes
    let processedText = text;
    
    // je + voyelle ‚Üí j'
    processedText = processedText.replace(/\bje ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "j'$1");
    
    // le/la + voyelle ‚Üí l'
    processedText = processedText.replace(/\b(?:le|la) ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "l'$1");
    
    // de + voyelle ‚Üí d'
    processedText = processedText.replace(/\bde ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "d'$1");
    
    // que + voyelle ‚Üí qu'
    processedText = processedText.replace(/\bque ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "qu'$1");
    
    // ne + voyelle ‚Üí n'
    processedText = processedText.replace(/\bne ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "n'$1");
    
    // te + voyelle ‚Üí t'
    processedText = processedText.replace(/\bte ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "t'$1");
    
    // se + voyelle ‚Üí s'
    processedText = processedText.replace(/\bse ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "s'$1");
    
    // me + voyelle ‚Üí m'
    processedText = processedText.replace(/\bme ([aeiouyh√†√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø])/g, "m'$1");
    
    // Cas sp√©ciaux
    processedText = processedText.replace(/\bce est\b/g, "c'est");
    processedText = processedText.replace(/\bce √©tait\b/g, "c'√©tait");
    
  return processedText;
        
        
        // INTERFACE
        function translate() {
            
            const inputText = document.getElementById('input-text').value.trim();
            if (!inputText) {
                document.getElementById('output-text').value = '';
                document.getElementById('analysis').style.display = 'none';
                return;
            }
            
            let result;
            if (direction === 'fr-to-ng') {
                result = translateFrToNg(inputText);
            } else {
                result = translateNgToFr(inputText);
            }
            
            document.getElementById('output-text').value = result.translation;
            showAnalysis(result.analysis, result.grammar);
        }
        
        function swapLanguages() {
            const inputLabel = document.getElementById('input-label');
            const outputLabel = document.getElementById('output-label');
            const inputText = document.getElementById('input-text');
            const outputText = document.getElementById('output-text');
            
            const tempLabel = inputLabel.textContent;
            inputLabel.textContent = outputLabel.textContent;
            outputLabel.textContent = tempLabel;
            
            const tempText = inputText.value;
            inputText.value = outputText.value;
            outputText.value = tempText;
            
            direction = direction === 'fr-to-ng' ? 'ng-to-fr' : 'fr-to-ng';
            translate();
        }
        
        function showAnalysis(analysisData, grammarNotes) {
            const analysis = document.getElementById('analysis');
            const wordAnalysis = document.getElementById('word-analysis');
            const grammarDiv = document.getElementById('grammar-notes');
            
            wordAnalysis.innerHTML = '';
            analysisData.forEach(item => {
                const tag = document.createElement('div');
                tag.className = 'word-tag';
                tag.innerHTML = `<strong>${item.original}</strong> ‚Üí ${item.translation} <em>(${item.type})</em>`;
                wordAnalysis.appendChild(tag);
            });
            
            grammarDiv.innerHTML = grammarNotes.map(note => `<div>üìù ${note}</div>`).join('');
            analysis.style.display = 'block';
        }
        
        // √âV√âNEMENTS
        document.getElementById('input-text').addEventListener('input', function() {
    console.log("Event d√©clench√©");
    setTimeout(translate, 300);
});
        
        window.onload = function() {
            console.log("Page charg√©e");
        };
        
        console.log("Script termin√©");
    </script>
</body>
</html>
